exports.id = "main";
exports.modules = {

/***/ "./src/solver/patterns-filler.js":
/*!***************************************!*\
  !*** ./src/solver/patterns-filler.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var scrabble_solver_commons_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! scrabble-solver-commons/models */ \"../scrabble-solver-commons/models/index.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar PatternsFiller =\n/*#__PURE__*/\nfunction () {\n  function PatternsFiller(config, collection) {\n    _classCallCheck(this, PatternsFiller);\n\n    this.config = config;\n    this.collection = collection;\n  }\n\n  _createClass(PatternsFiller, [{\n    key: \"fill\",\n    value: function fill(pattern, tiles) {\n      var _this = this;\n\n      var patterns = [];\n\n      if (pattern.getNumberOfEmptyCells() > tiles.length) {\n        return [];\n      }\n\n      var onPatternFound = function onPatternFound(newPattern) {\n        return patterns.push(newPattern);\n      };\n\n      this.generateBlankTilesPermutations(tiles).forEach(function (tilesPermutation) {\n        return _this.fillPattern(pattern, String(pattern), tilesPermutation, onPatternFound);\n      });\n      return patterns;\n    }\n  }, {\n    key: \"fillPattern\",\n    value: function fillPattern(pattern, word, tiles, onPatternFound) {\n      var _this2 = this;\n\n      var indexOfFirstCellWithoutTile = pattern.getIndexOfFirstCellWithoutTile();\n\n      if (indexOfFirstCellWithoutTile === -1) {\n        if (this.canAddPattern(pattern, word)) {\n          onPatternFound(pattern.clone());\n        }\n      } else {\n        tiles.forEach(function (tile, index) {\n          var remainingTiles = tiles.slice(0, index).concat(tiles.slice(index + 1));\n          var previousTile = pattern.cells[indexOfFirstCellWithoutTile].tile;\n          pattern.cells[indexOfFirstCellWithoutTile].tile = tile;\n          var indexOfNextCellWithoutTile = pattern.getIndexOfFirstCellWithoutTile();\n          var newWordPrefix = word.substring(0, indexOfFirstCellWithoutTile) + tile.character;\n          var newWord = newWordPrefix + word.substring(indexOfFirstCellWithoutTile + 1);\n\n          if (indexOfNextCellWithoutTile === -1) {\n            if (_this2.canAddPattern(pattern, newWord)) {\n              onPatternFound(pattern.clone());\n            }\n          } else if (_this2.collection.hasMore(newWordPrefix)) {\n            _this2.fillPattern(pattern, newWord, remainingTiles, onPatternFound);\n          }\n\n          pattern.cells[indexOfFirstCellWithoutTile].tile = previousTile;\n        });\n      }\n    }\n  }, {\n    key: \"canAddPattern\",\n    value: function canAddPattern(pattern, word) {\n      var _this3 = this;\n\n      return this.collection.has(word) && pattern.getCollisions().map(String).every(function (collision) {\n        return _this3.collection.has(collision);\n      });\n    }\n  }, {\n    key: \"generateBlankTilesPermutations\",\n    value: function generateBlankTilesPermutations(tiles) {\n      var _this4 = this;\n\n      var alphabet = this.config.alphabet;\n      var firstBlankIndex = tiles.findIndex(function (_ref) {\n        var character = _ref.character,\n            isBlank = _ref.isBlank;\n        return isBlank && !alphabet.includes(character);\n      });\n\n      if (firstBlankIndex === -1) {\n        return [tiles];\n      }\n\n      var remainingTiles = tiles.slice(0, firstBlankIndex).concat(tiles.slice(firstBlankIndex + 1));\n      return this.config.alphabet.reduce(function (permutations, character) {\n        var newTile = new scrabble_solver_commons_models__WEBPACK_IMPORTED_MODULE_0__[\"Tile\"]({\n          character: character,\n          isBlank: true\n        });\n        var newTiles = [].concat(_toConsumableArray(remainingTiles), [newTile]);\n        return permutations.concat(_this4.generateBlankTilesPermutations(newTiles));\n      }, []);\n    }\n  }]);\n\n  return PatternsFiller;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PatternsFiller);\n\n//# sourceURL=webpack:///./src/solver/patterns-filler.js?");

/***/ })

};