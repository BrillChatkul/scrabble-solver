exports.id = "main";
exports.modules = {

/***/ "./src/solver/patterns-filler.js":
/*!***************************************!*\
  !*** ./src/solver/patterns-filler.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var scrabble_solver_commons_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! scrabble-solver-commons/models */ \"../scrabble-solver-commons/models/index.js\");\n\n\nclass PatternsFiller {\n  constructor(config, collection) {\n    this.config = config;\n    this.collection = collection;\n  }\n\n  fill(pattern, tiles) {\n    const patterns = [];\n\n    if (pattern.getNumberOfEmptyCells() > tiles.length) {\n      return [];\n    }\n\n    const onPatternFound = newPattern => patterns.push(newPattern);\n\n    this.generateBlankTilesPermutations(tiles).forEach(tilesPermutation => this.fillPattern(pattern, String(pattern), tilesPermutation, onPatternFound));\n    return patterns;\n  }\n\n  fillPattern(pattern, word, tiles, onPatternFound) {\n    const indexOfFirstCellWithoutTile = pattern.getIndexOfFirstCellWithoutTile();\n\n    if (indexOfFirstCellWithoutTile === -1) {\n      if (this.canAddPattern(pattern, word)) {\n        onPatternFound(pattern.clone());\n      }\n    } else {\n      tiles.forEach((tile, index) => {\n        const remainingTiles = tiles.slice(0, index).concat(tiles.slice(index + 1));\n        const previousTile = pattern.cells[indexOfFirstCellWithoutTile].tile;\n        pattern.cells[indexOfFirstCellWithoutTile].tile = tile;\n        const indexOfNextCellWithoutTile = pattern.getIndexOfFirstCellWithoutTile();\n        const newWordPrefix = word.substring(0, indexOfFirstCellWithoutTile) + tile.character;\n        const newWord = newWordPrefix + word.substring(indexOfFirstCellWithoutTile + 1);\n\n        if (indexOfNextCellWithoutTile === -1) {\n          if (this.canAddPattern(pattern, newWord)) {\n            onPatternFound(pattern.clone());\n          }\n        } else if (this.collection.hasMore(newWordPrefix)) {\n          this.fillPattern(pattern, newWord, remainingTiles, onPatternFound);\n        }\n\n        pattern.cells[indexOfFirstCellWithoutTile].tile = previousTile;\n      });\n    }\n  }\n\n  canAddPattern(pattern, word) {\n    return this.collection.has(word) && pattern.getCollisions().map(String).every(collision => this.collection.has(collision));\n  }\n\n  generateBlankTilesPermutations(tiles) {\n    const {\n      alphabet\n    } = this.config;\n    const firstBlankIndex = tiles.findIndex(({\n      character,\n      isBlank\n    }) => isBlank && !alphabet.includes(character));\n\n    if (firstBlankIndex !== -1) {\n      const remainingTiles = tiles.slice(0, firstBlankIndex).concat(tiles.slice(firstBlankIndex + 1));\n      return this.config.alphabet.reduce((permutations, character) => {\n        const newTile = new scrabble_solver_commons_models__WEBPACK_IMPORTED_MODULE_0__[\"Tile\"]({\n          character,\n          isBlank: true\n        });\n        const newTiles = [...remainingTiles, newTile];\n        return permutations.concat(this.generateBlankTilesPermutations(newTiles));\n      }, []);\n    }\n\n    return [tiles];\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PatternsFiller);\n\n//# sourceURL=webpack:///./src/solver/patterns-filler.js?");

/***/ })

};